

```{r}
options(digitis = 3)
options(scipen = 10^5) 
options(help_type = "html")

library(tidyverse)
library(parallel)
#load R functions
sapply(list.files("R/", ".r", full.names = TRUE), source)
set.seed(0203)
options(scipen = 10^6)


library(INLA)

```

```{r}
## simple poisson regression
n = 200
x = runif(n)
eta = 1 + x
lambda = exp(eta)
y = rpois(n, lambda = lambda)
y0 = y

## missing values:
y0[sample(n, 40)] = NA


## link = 1 is a shortcut for rep(1, <n>) where <n> is the appropriate
## length. here '1' is a reference to the first 'family', ie
## 'family[1]'
r <- inla(y0 ~ x,  family = "poisson"
  , data = data.frame(y0, x)
  # link =1 the prediction are in the same scale as the data
  , control.predictor = list(link = 1)
  # config TURE to extract postrior
#  , control.compute = list(config = TRUE)#, return.marginals.predictor = TRUE)
)
#not sure what would you need this for , it does not change posterior sample
summary(r$marginals.fitted.values)

summary(r)
names(r)
plot(r$summary.fitted.values$mean[is.na(y0)], y[is.na(y0)])




r$summary.linear.predictor$mean[is.na(y0)][1:3]
r$summary.fitted.values$mean[is.na(y0)][1:3]
a[is.na(y0)][1:3]

#prediction error, analytical
sig <- r$summary.fitted.values$sd
mu <- r$summary.fitted.values$mean
sig_pred <- sqrt(sig^2 + mu)

sm <- sads:::rpoilog(500, a[1], b[1])
#hist(sm)
sd(sm)
sig_pred[1]


# from sim posterior
ps <- inla.posterior.sample(500, r)
pos_y <- exp(inla.posterior.sample.eval("Predictor", ps))
poss_y <- apply(pos_y, 1:2, \(l) rpois(1, l))

plot(jitter(apply(poss_y, 1, quantile, .975)), jitter(ci[, 2]))
cor(apply(poss_y, 1, quantile, .975), ci[, 2])

summary(apply(poss_y, 1, sd))
cor(apply(poss_y, 1, sd), sigma_pred)
plot(apply(poss_y, 1, sd), sigma_pred)
hist(pos_y[1, ])
hist(poss_y[1, ])



#prediction error, simulation
#parametric bootstrap
sim_y <- replicate(500,
  rnorm(n, r$summary.fitted.values$mean, r$summary.fitted.values$sd) %>%
    rpois(n, .)
)
hist(sim_y[1, ])

cor(apply(sim_y, 1, sd), sigma_pred)
plot(apply(sim_y, 1, sd), sigma_pred)



#a <- log(mu) - .5 * sig^2
#b <- sqrt(log(sig^2 / mu^2 + 1))
a <- r$summary.linear.predictor$mean
b <- r$summary.linear.predictor$sd

ci_poilog <- \(mu, sigma) {
  sapply(seq_len(length(mu)), \(i) {
    sapply(c(.025, .975), \(q) {
      sads:::qpoilog(q, mu[i], sigma[i])
    }
    )
  }) %>% t
}

ci <- ci_poilog(a, b)
mean((ci[, 1] < y & ci[, 2] > y)[is.na(y0)])


cbind(
  apply(poss_y, 1, quantile, c(.025, .975)) %>% t
  , apply(sim_y, 1, quantile, c(.025, .975)) %>% t
  , ci
) %>% round




```
Conlussion. For marginal predictions, the analytical results are adecuate and faster than the simulation.
The simulation maybe better for funntion involving the joint distribution of several latent variables


```{r}
## simple poisson regression
n = 200
k = 30
x = runif(n) - mean(x)
i = sample(1:k, n, replace = TRUE)
i2 = k + i
e = MASS::mvrnorm(k, c(0, 0), matrix(c(1, 0.5, 0.5, 1), 2, 2, byrow = TRUE))
eta = 1 + e[i, 1] + x * e[i, 2]
lambda = exp(eta)
y = rpois(n, lambda = lambda)
y0 = y


## missing values:
y0[sample(n, 40)] = NA

## link = 1 is a shortcut for rep(1, <n>) where <n> is the appropriate
## length. here '1' is a reference to the first 'family', ie
## 'family[1]'
m_inla <- inla(y0 ~ x
  + f(i, model = "iid2d", n = 2 * n)
  + f(i2, x, copy = "i")
  , family = "poisson"
  , data = data.frame(y0, x)
  # link =1 the prediction are in the same scale as the data
  , control.predictor = list(link = 1)
  # config TURE to extract postrior
#  , control.compute = list(config = TRUE)#, return.marginals.predictor = TRUE)
)
summary(m_inla)

inla.doc("iid2d")


library(lme4)
m_mer <- glmer(y0 ~ x
  + (x | i)
  , family = "poisson"
  , data = data.frame(y0, x, i)
)
summary(m_mer)


plot(m_inla$summary.fitted.values$mean[is.na(y0)], y[is.na(y0)])
plot(predict(m_mer, data.frame(y0, x), type = "response") [is.na(y0)], y[is.na(y0)])

plot(
  m_inla$summary.fitted.values$mean[is.na(y0)]
  , predict(m_mer, data.frame(y0, x), type = "response") [is.na(y0)]
)


library(brms)
m_brm <- brm(y0 ~ x  + (x | i)
  , family = "poisson"
  , data = data.frame(y0, x, i)
)
summary(m_brm)

```